// Replicate API интеграция для генерации AI-портретов
// Использует модель zsxkib/flux-pulid для identity-preserving генерации

import Replicate from "replicate"

const REPLICATE_API_TOKEN = process.env.REPLICATE_API_TOKEN

// Инициализация клиента Replicate
const replicate = REPLICATE_API_TOKEN
  ? new Replicate({
      auth: REPLICATE_API_TOKEN,
    })
  : null

// Модель для identity-preserving портретов
const FLUX_PULID_MODEL = "zsxkib/flux-pulid"

export interface ReplicateGenerationOptions {
  prompt: string
  referenceImages?: string[] // base64 или URLs
  seed?: number
  numInferenceSteps?: number // 20-50, по умолчанию 28
  guidanceScale?: number // 1-20, по умолчанию 4
  width?: number // по умолчанию 896
  height?: number // по умолчанию 1152
  numOutputs?: number // 1-4, по умолчанию 1
  idWeight?: number // 0-3, вес identity preservation, по умолчанию 1
}

export interface ReplicateGenerationResult {
  url: string
  seed?: number
}

/**
 * Генерация одного портрета через Replicate Flux-PuLID
 * @param options Параметры генерации
 * @returns URL сгенерированного изображения
 */
export async function generatePortrait(options: ReplicateGenerationOptions): Promise<string> {
  if (!replicate) {
    throw new Error("REPLICATE_API_TOKEN is not configured")
  }

  const {
    prompt,
    referenceImages = [],
    seed,
    numInferenceSteps = 28,
    guidanceScale = 4,
    width = 896,
    height = 1152,
    numOutputs = 1,
    idWeight = 1,
  } = options

  try {
    // Формируем входные параметры для модели
    const input: Record<string, unknown> = {
      prompt,
      num_steps: numInferenceSteps,
      guidance_scale: guidanceScale,
      width,
      height,
      num_outputs: numOutputs,
      id_weight: idWeight,
    }

    // Добавляем seed если указан
    if (seed !== undefined) {
      input.seed = seed
    }

    // Добавляем главное референсное изображение (main_face_image)
    if (referenceImages.length > 0) {
      input.main_face_image = referenceImages[0]
    }

    // Запускаем генерацию
    const output = (await replicate.run(FLUX_PULID_MODEL as `${string}/${string}`, {
      input,
    })) as string[] | string

    // Обрабатываем результат (может быть массив или строка)
    const imageUrl = Array.isArray(output) ? output[0] : output

    if (!imageUrl) {
      throw new Error("No image generated by Replicate")
    }

    return imageUrl
  } catch (error) {
    console.error("[Replicate] Portrait generation error:", error)
    throw new Error(`Replicate generation failed: ${error instanceof Error ? error.message : "Unknown error"}`)
  }
}

/**
 * Генерация нескольких портретов с rate limiting
 * @param prompts Массив промптов для генерации
 * @param referenceImages Референсные изображения пользователя
 * @param concurrency Количество одновременных запросов (по умолчанию 3)
 * @returns Массив URL сгенерированных изображений
 */
export async function generateMultiplePortraits(
  prompts: string[],
  referenceImages?: string[],
  concurrency = 3,
): Promise<string[]> {
  if (!replicate) {
    throw new Error("REPLICATE_API_TOKEN is not configured")
  }

  const results: string[] = []
  const errors: Array<{ index: number; error: Error }> = []

  // Генерируем батчами для контроля нагрузки
  for (let i = 0; i < prompts.length; i += concurrency) {
    const batch = prompts.slice(i, i + concurrency)
    const batchStartIndex = i

    console.log(`[Replicate] Processing batch ${i / concurrency + 1} (${batch.length} prompts)`)

    const batchResults = await Promise.allSettled(
      batch.map((prompt, batchIndex) =>
        generatePortrait({
          prompt,
          referenceImages,
          seed: Date.now() + batchIndex, // Уникальный seed для воспроизводимости
        }),
      ),
    )

    // Обрабатываем результаты батча
    batchResults.forEach((result, batchIndex) => {
      const globalIndex = batchStartIndex + batchIndex

      if (result.status === "fulfilled") {
        results.push(result.value)
        console.log(`[Replicate] ✓ Image ${globalIndex + 1}/${prompts.length} generated`)
      } else {
        console.error(`[Replicate] ✗ Image ${globalIndex + 1}/${prompts.length} failed:`, result.reason)
        errors.push({ index: globalIndex, error: result.reason })
        // Добавляем placeholder при ошибке
        results.push("/generation-failed.jpg")
      }
    })

    // Задержка между батчами для соблюдения rate limits
    if (i + concurrency < prompts.length) {
      await new Promise((resolve) => setTimeout(resolve, 1000))
    }
  }

  // Логируем итоговую статистику
  const successCount = results.filter((url) => url !== "/generation-failed.jpg").length
  console.log(`[Replicate] Generation complete: ${successCount}/${prompts.length} successful`)

  if (errors.length > 0) {
    console.warn(`[Replicate] ${errors.length} generation(s) failed:`, errors)
  }

  return results
}

/**
 * Проверка доступности Replicate API
 * @returns Статус подключения и информация о модели
 */
export async function testReplicateConnection(): Promise<{
  success: boolean
  message: string
  modelInfo?: unknown
}> {
  if (!replicate) {
    return {
      success: false,
      message: "REPLICATE_API_TOKEN is not configured",
    }
  }

  try {
    // Получаем информацию о модели
    const model = await replicate.models.get("zsxkib", "flux-pulid")

    return {
      success: true,
      message: "Replicate API connected successfully",
      modelInfo: {
        name: model.name,
        owner: model.owner,
        description: model.description,
        latestVersion: model.latest_version?.id,
      },
    }
  } catch (error) {
    return {
      success: false,
      message: error instanceof Error ? error.message : "Unknown error connecting to Replicate",
    }
  }
}

/**
 * Получение статуса выполнения prediction
 * @param predictionId ID prediction из Replicate
 * @returns Статус и результат (если готов)
 */
export async function getPredictionStatus(
  predictionId: string,
): Promise<{
  status: string
  output?: string[] | string
  error?: string
}> {
  if (!replicate) {
    throw new Error("REPLICATE_API_TOKEN is not configured")
  }

  try {
    const prediction = await replicate.predictions.get(predictionId)

    return {
      status: prediction.status,
      output: prediction.output as string[] | string | undefined,
      error: prediction.error as string | undefined,
    }
  } catch (error) {
    throw new Error(`Failed to get prediction status: ${error instanceof Error ? error.message : "Unknown error"}`)
  }
}

/**
 * Конвертация base64 в URL для Replicate
 * (Replicate предпочитает URLs, но также поддерживает data URIs)
 * @param base64String Base64 строка (с префиксом data: или без)
 * @returns Корректный data URI
 */
export function prepareImageForReplicate(base64String: string): string {
  // Если уже data URI, возвращаем как есть
  if (base64String.startsWith("data:")) {
    return base64String
  }

  // Если URL, возвращаем как есть
  if (base64String.startsWith("http://") || base64String.startsWith("https://")) {
    return base64String
  }

  // Иначе добавляем префикс data URI
  return `data:image/jpeg;base64,${base64String}`
}
